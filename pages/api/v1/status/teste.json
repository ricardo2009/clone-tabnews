ServerResponse {
  _events: [Object: null prototype] {
    finish: [Function: bound resOnFinish], // Evento disparado quando a resposta é finalizada
    pipe: [Function: bound onceWrapper] { listener: [Function (anonymous)] } // Evento disparado quando a resposta é enviada para um fluxo de saída
  },
  _eventsCount: 2, // Número de eventos registrados
  _maxListeners: undefined, // Número máximo de ouvintes para eventos
  outputData: [], // Dados de saída
  outputSize: 0, // Tamanho dos dados de saída
  writable: true, // Indica se a resposta pode ser gravada
  destroyed: false, // Indica se a resposta foi destruída
  _last: false, // Indica se é a última resposta
  chunkedEncoding: false, // Indica se a codificação chunked está sendo usada
  shouldKeepAlive: true, // Indica se a conexão deve ser mantida viva
  maxRequestsOnConnectionReached: false, // Indica se o número máximo de solicitações por conexão foi atingido
  _defaultKeepAlive: true, // Indica se a conexão deve ser mantida viva por padrão
  useChunkedEncodingByDefault: true, // Indica se a codificação chunked deve ser usada por padrão
  sendDate: true, // Indica se a data deve ser enviada
  _removedConnection: false, // Indica se a conexão foi removida
  _removedContLen: false, // Indica se o comprimento do conteúdo foi removido
  _removedTE: false, // Indica se a codificação TE foi removida
  strictContentLength: false, // Indica se o comprimento do conteúdo é estrito
  _contentLength: 73, // Comprimento do conteúdo
  _hasBody: true, // Indica se a resposta possui corpo
  _trailer: '', // Trailer da resposta
  finished: true, // Indica se a resposta foi finalizada
  _headerSent: true, // Indica se o cabeçalho foi enviado
  _closed: false, // Indica se a resposta foi fechada
  socket: <ref *1> Socket { // Objeto de soquete associado à resposta
    connecting: false, // Indica se o soquete está conectando
    _hadError: false, // Indica se ocorreu um erro no soquete
    _parent: null, // Objeto pai do soquete
    _host: null, // Host do soquete
    _closeAfterHandlingError: false, // Indica se o soquete deve ser fechado após o tratamento do erro
    _events: [Object], // Eventos do soquete
    _readableState: [ReadableState], // Estado legível do soquete
    _writableState: [WritableState], // Estado gravável do soquete
    allowHalfOpen: true, // Indica se a conexão permite meia abertura
    _maxListeners: undefined, // Número máximo de ouvintes para eventos
    _eventsCount: 8, // Número de eventos registrados
    _sockname: null, // Nome do soquete
    _pendingData: null, // Dados pendentes do soquete
    _pendingEncoding: '', // Codificação pendente do soquete
    server: [Server], // Servidor associado ao soquete
    _server: [Server], // Servidor associado ao soquete
    parser: [HTTPParser], // Analisador HTTP associado ao soquete
    on: [Function: socketListenerWrap], // Função para adicionar um ouvinte de evento ao soquete
    addListener: [Function: socketListenerWrap], // Função para adicionar um ouvinte de evento ao soquete
    prependListener: [Function: socketListenerWrap], // Função para adicionar um ouvinte de evento ao soquete
    setEncoding: [Function: socketSetEncoding], // Função para definir a codificação do soquete
    _paused: false, // Indica se o fluxo de entrada do soquete está pausado
    _httpMessage: [Circular *2], // Mensagem HTTP associada ao soquete
    [Symbol(async_id_symbol)]: 64911, // ID assíncrono do soquete
    [Symbol(kHandle)]: [TCP], // Manipulador do soquete
    [Symbol(lastWriteQueueSize)]: 0, // Tamanho da fila de gravação do soquete
    [Symbol(timeout)]: null, // Tempo limite do soquete
    [Symbol(kBuffer)]: null, // Buffer do soquete
    [Symbol(kBufferCb)]: null, // Função de retorno de chamada do buffer do soquete
    [Symbol(kBufferGen)]: null, // Gerador de buffer do soquete
    [Symbol(shapeMode)]: true, // Modo de forma do soquete
    [Symbol(kCapture)]: false, // Indica se o soquete está capturando
    [Symbol(kSetNoDelay)]: true, // Indica se o atraso do soquete deve ser definido como zero
    [Symbol(kSetKeepAlive)]: false, // Indica se o soquete deve manter a conexão viva
    [Symbol(kSetKeepAliveInitialDelay)]: 0, // Atraso inicial para manter a conexão viva
    [Symbol(kBytesRead)]: 0, // Número de bytes lidos do soquete
    [Symbol(kBytesWritten)]: 0 // Número de bytes gravados no soquete
  },
  _server: Server { // Servidor associado à resposta
    maxHeaderSize: undefined, // Tamanho máximo do cabeçalho
    insecureHTTPParser: undefined, // Analisador HTTP inseguro
    requestTimeout: 300000, // Tempo limite da solicitação
    headersTimeout: 60000, // Tempo limite dos cabeçalhos
    keepAliveTimeout: 5000, // Tempo limite da conexão mantida viva  00000000000
    connectionsCheckingInterval: 30000, // Intervalo de verificação de conexões
    requireHostHeader: true, // Indica se o cabeçalho do host é obrigatório
    joinDuplicateHeaders: undefined, // Indica se os cabeçalhos duplicados devem ser mesclados
    rejectNonStandardBodyWrites: false, // Indica se gravações de corpo não padrão devem ser rejeitadas
    _events: [Object: null prototype], // Eventos do servidor
    _eventsCount: 5, // Número de eventos registrados
    _maxListeners: undefined, // Número máximo de ouvintes para eventos
    _connections: 1, // Número de conexões
    _handle: [Object], // Manipulador do servidor
    _usingWorkers: false, // Indica se estão sendo usados trabalhadores
    _workers: [], // Trabalhadores do servidor
    _unref: false, // Indica se o servidor está desreferenciado
    _listeningId: 1, // ID de escuta do servidor
    allowHalfOpen: true, // Indica se a conexão permite meia abertura
    pauseOnConnect: false, // Indica se a conexão deve ser pausada na conexão
    noDelay: true, // Indica se o atraso deve ser definido como zero
    keepAlive: false, // Indica se a conexão deve ser mantida viva
    keepAliveInitialDelay: 0, // Atraso inicial para manter a conexão viva
    highWaterMark: 16384, // Marca de alta água
    httpAllowHalfOpen: false, // Indica se a conexão HTTP permite meia abertura
    timeout: 0, // Tempo limite do servidor
    maxHeadersCount: null, // Número máximo de cabeçalhos
    maxRequestsPerSocket: 0, // Número máximo de solicitações por soquete
    _connectionKey: '4:null:3000', // Chave de conexão do servidor
    [Symbol(IncomingMessage)]: [Function: IncomingMessage], // Construtor de mensagens de entrada
    [Symbol(ServerResponse)]: [Function: ServerResponse], // Construtor de respostas do servidor
    [Symbol(shapeMode)]: false, // Modo de forma do servidor
    [Symbol(kCapture)]: false, // Indica se o servidor está capturando
    [Symbol(async_id_symbol)]: 37, // ID assíncrono do servidor
    [Symbol(kUniqueHeaders)]: null, // Cabeçalhos únicos do servidor
    [Symbol(http.server.connections)]: ConnectionsList {}, // Lista de conexões do servidor
    [Symbol(http.server.connectionsCheckingInterval)]: Timeout { // Intervalo de verificação de conexões do servidor
      _idleTimeout: 30000, // Tempo limite de inatividade
      _idlePrev: [TimersList], // Lista de temporizadores anteriores
      _idleNext: [TimersList], // Lista de temporizadores seguintes
      _idleStart: 11611234, // Início da inatividade
      _onTimeout: [Function: bound checkConnections], // Função chamada quando ocorre o tempo limite
      _timerArgs: undefined, // Argumentos do temporizador
      _repeat: 30000, // Intervalo de repetição
      _destroyed: false, // Indica se o temporizador foi destruído
      [Symbol(refed)]: false, // Indica se o temporizador foi referenciado
      [Symbol(kHasPrimitive)]: false, // Indica se o temporizador tem um valor primitivo
      [Symbol(asyncId)]: 39, // ID assíncrono do temporizador
      [Symbol(triggerId)]: 38 // ID de gatilho do temporizador
    }
  },
  parser: HTTPParser { // Analisador HTTP associado à resposta
    '0': null, // Valor do índice 0
    '1': [Function: parserOnHeaders], // Função chamada quando os cabeçalhos são analisados
    '2': [Function: parserOnHeadersComplete], // Função chamada quando os cabeçalhos são completamente analisados
    '3': [Function: parserOnBody], // Função chamada quando o corpo é analisado
    '4': [Function: parserOnMessageComplete], // Função chamada quando a mensagem é completamente analisada
    '5': [Function: bound onParserExecute], // Função chamada quando o analisador é executado
    '6': [Function: bound onParserTimeout], // Função chamada quando ocorre o tempo limite do analisador
    _headers: [], // Cabeçalhos analisados
    _url: '', // URL analisada
    socket: [Circular *1], // Soquete associado ao analisador
    incoming: [IncomingMessage], // Mensagem de entrada associada ao analisador
    outgoing: null, // Mensagem de saída associada ao analisador
    maxHeaderPairs: 2000, // Número máximo de pares de cabeçalho
    _consumed: true, // Indica se o analisador consumiu os dados
    onIncoming: [Function: bound parserOnIncoming], // Função chamada quando uma mensagem de entrada é recebida
    joinDuplicateHeaders: null, // Indica se os cabeçalhos duplicados devem ser mesclados
    [Symbol(resource_symbol)]: [HTTPServerAsyncResource] // Recurso assíncrono do servidor HTTP
  },
  on: [Function: socketListenerWrap], // Função para adicionar um ouvinte de evento à resposta
  addListener: [Function: socketListenerWrap], // Função para adicionar um ouvinte de evento à resposta
  prependListener: [Function: socketListenerWrap], // Função para adicionar um ouvinte de evento à resposta
  setEncoding: [Function: socketSetEncoding], // Função para definir a codificação do soquete
  _paused: false, // Indica se o fluxo de entrada está pausado
  _httpMessage: [Circular *2], // Mensagem HTTP associada à resposta
  [Symbol(async_id_symbol)]: 64911, // ID assíncrono da resposta
  [Symbol(kHandle)]: TCP { // Manipulador da resposta
    reading: true, // Indica se a leitura está ocorrendo
    onconnection: null, // Função chamada quando ocorre uma conexão
    _consumed: true, // Indica se os dados foram consumidos
    [Symbol(owner_symbol)]: [Circular *1] // Objeto proprietário da resposta
  },
  [Symbol(lastWriteQueueSize)]: 0, // Tamanho da fila de gravação
  [Symbol(timeout)]: null, // Tempo limite da resposta
  [Symbol(kBuffer)]: null, // Buffer da resposta
  [Symbol(kBufferCb)]: null, // Função de retorno de chamada do buffer
  [Symbol(kBufferGen)]: null, // Gerador de buffer
  [Symbol(shapeMode)]: true, // Modo de forma
  [Symbol(kCapture)]: false, // Indica se está capturando
  [Symbol(kSetNoDelay)]: true, // Indica se o atraso deve ser definido como zero
  [Symbol(kSetKeepAlive)]: false, // Indica se a conexão deve ser mantida viva
  [Symbol(kSetKeepAliveInitialDelay)]: 0, // Atraso inicial para manter a conexão viva
  [Symbol(kBytesRead)]: 0, // Número de bytes lidos
  [Symbol(kBytesWritten)]: 0 // Número de bytes gravados
},
_header: 'HTTP/1.1 200 OK\r\n' + // Cabeçalho da resposta
  'Content-Type: application/json; charset=utf-8\r\n' + // Tipo de conteúdo da resposta
  'ETag: "bqxioylojy21"\r\n' + // ETag da resposta
  'Content-Length: 73\r\n' + // Comprimento do conteúdo da resposta
  'Vary: Accept-Encoding\r\n' + // Variante da resposta
  'Date: Fri, 03 May 2024 16:36:17 GMT\r\n' + // Data da resposta
  'Connection: keep-alive\r\n' + // Tipo de conexão da resposta
  'Keep-Alive: timeout=5\r\n' + // Tempo limite da conexão mantida viva
  '\r\n',
_keepAliveTimeout: 5000, // Tempo limite da conexão mantida viva
_onPendingData: [Function: bound updateOutgoingData], // Função chamada quando há dados pendentes de saída
req: IncomingMessage { // Mensagem de entrada associada à resposta
  _events: [Object], // Eventos da mensagem de entrada
  _readableState: [ReadableState], // Estado legível da mensagem de entrada
  _maxListeners: undefined, // Número máximo de ouvintes para eventos
  socket: [Circular *1], // Soquete associado à mensagem de entrada
  httpVersionMajor: 1, // Versão principal do protocolo HTTP
  httpVersionMinor: 1, // Versão secundária do protocolo HTTP
  httpVersion: '1.1', // Versão do protocolo HTTP
  complete: true, // Indica se a mensagem de entrada está completa
  rawHeaders: [Array], // Cabeçalhos brutos da mensagem de entrada
  rawTrailers: [], // Trailers brutos da mensagem de entrada
  joinDuplicateHeaders: null, // Indica se os cabeçalhos duplicados devem ser mesclados
  aborted: false, // Indica se a mensagem de entrada foi abortada
  upgrade: false, // Indica se a mensagem de entrada é uma atualização
  url: '/api/v1/status', // URL da mensagem de entrada
  method: 'GET', // Método da mensagem de entrada
  statusCode: null, // Código de status da mensagem de entrada
  statusMessage: null, // Mensagem de status da mensagem de entrada
  client: [Circular *1], // Cliente associado à mensagem de entrada
  _consuming: false, // Indica se a mensagem de entrada está sendo consumida
  _dumped: false, // Indica se a mensagem de entrada foi descartada
  cookies: [Getter/Setter], // Cookies da mensagem de entrada
  _eventsCount: 2, // Número de eventos registrados
  query: {}, // Consulta da mensagem de entrada
  previewData: [Getter/Setter], // Dados de visualização da mensagem de entrada
  preview: [Getter/Setter], // Visualização da mensagem de entrada
  body: '', // Corpo da mensagem de entrada
  [Symbol(shapeMode)]: true, // Modo de forma da mensagem de entrada
  [Symbol(kCapture)]: false, // Indica se a mensagem de entrada está capturando
  [Symbol(kHeaders)]: { // Cabeçalhos da mensagem de entrada
    host: 'localhost:3000', // Host da mensagem de entrada
    connection: 'keep-alive', // Tipo de conexão da mensagem de entrada
    accept: '*/*', // Tipo de conteúdo aceito pela mensagem de entrada
    'accept-language': '*', // Idioma aceito pela mensagem de entrada
    'sec-fetch-mode': 'cors', // Modo de busca segura da mensagem de entrada
    'user-agent': 'node', // Agente do usuário da mensagem de entrada
    'accept-encoding': 'gzip, deflate' // Codificação aceita pela mensagem de entrada
  },
  [Symbol(kHeadersCount)]: 14, // Número de cabeçalhos da mensagem de entrada
  [Symbol(kTrailers)]: null, // Trailers da mensagem de entrada
  [Symbol(kTrailersCount)]: 0, // Número de trailers da mensagem de entrada
  [Symbol(NextRequestMeta)]: {
    __NEXT_INIT_URL: 'http://localhost:3000/api/v1/status',
    __NEXT_INIT_QUERY: {},
    _protocol: 'http',
    __NEXT_CLONABLE_BODY: [Object],
    __nextHadTrailingSlash: false,
    __nextIsLocaleDomain: false
  }
},
_sent100: false,
_expect_continue: false,
_maxRequestsPerSocket: 0,
setHeader: [Function (anonymous)],
statusCode: 200,
flush: [Function: flush],
write: [Function (anonymous)],
end: [Function (anonymous)],
on: [Function: on],
writeHead: [Function: writeHead],
status: [Function (anonymous)],
send: [Function (anonymous)],
json: [Function (anonymous)],
redirect: [Function (anonymous)],
setPreviewData: [Function (anonymous)],
clearPreviewData: [Function (anonymous)],
revalidate: [Function (anonymous)],
statusMessage: 'OK',
[Symbol(shapeMode)]: false,
[Symbol(kCapture)]: false,
[Symbol(kBytesWritten)]: 0,
[Symbol(kNeedDrain)]: false,
[Symbol(corked)]: 0,
[Symbol(kOutHeaders)]: [Object: null prototype] {
  'content-type': ['Content-Type', 'application/json; charset=utf-8'],
  etag: ['ETag', '"bqxioylojy21"'],
  'content-length': ['Content-Length', 73],
  vary: ['Vary', 'Accept-Encoding']
},
[Symbol(errored)]: null,
[Symbol(kHighWaterMark)]: 16384,
[Symbol(kRejectNonStandardBodyWrites)]: false,
[Symbol(kUniqueHeaders)]: null
}
